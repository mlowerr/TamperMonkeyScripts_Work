// ==UserScript==
// @name         ADO Contextual Printer (DOM Based)
// @namespace    http://tampermonkey.net/
// @version      2.0
// @description  Injects toolbar directly into .work-item-form-page. Scrapes ID contextually.
// @author       Gemini
// @match        https://dev.azure.com/*
// @match        https://*.visualstudio.com/*
// @grant        GM_registerMenuCommand
// @grant        GM_setClipboard
// ==/UserScript==

(function() {
    'use strict';

    // --- Configuration ---
    const API_VERSION = "6.0";
    const CONTAINER_SELECTOR = '.work-item-form-page';
    const LINK_SELECTOR = 'a[href*="/_workitems/edit/"]';

    // Work Item Hierarchy
    const HIERARCHY = {
        'Initiative': 0,
        'Epic': 1,
        'Feature': 2,
        'User Story': 3,
        'Bug': 3
    };

    // --- API Helpers ---

    function getBaseApiUrl() {
        const pathParts = window.location.pathname.split('/');
        if (window.location.hostname.endsWith('.visualstudio.com') && pathParts[1]) {
            return `${window.location.origin}/${pathParts[1]}/_apis/wit/workitems`;
        }
        return `${window.location.origin}/_apis/wit/workitems`;
    }

    async function fetchWorkItem(id) {
        const url = `${getBaseApiUrl()}/${id}?$expand=relations&api-version=${API_VERSION}`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (e) {
            console.error(`Failed to fetch ID ${id}`, e);
            return null;
        }
    }

    function getTypeLetter(typeName) {
        if (!typeName) return "?";
        const typeMap = {
            'Initiative': 'I',
            'Epic': 'E',
            'Feature': 'F',
            'User Story': 'S',
            'Bug': 'B'
        };
        return typeMap[typeName] || typeName.charAt(0).toUpperCase();
    }

    function shouldStopTraversal(typeName) {
        // Stop if we're at Story or Bug level (don't go deeper)
        return typeName === 'User Story' || typeName === 'Bug';
    }

    // --- Hierarchy Logic ---

    async function traverseDown(itemId, visitedSet, resultsArray, level = 0) {
        if (visitedSet.has(itemId)) return;
        visitedSet.add(itemId);

        const item = await fetchWorkItem(itemId);
        if (!item) return;

        const type = item.fields['System.WorkItemType'];
        const state = item.fields['System.State'];
        const letter = getTypeLetter(type);
        const title = item.fields['System.Title'];
        const assignedTo = item.fields['System.AssignedTo']?.displayName || 'Unassigned';
        const url = item._links?.html?.href || '#';

        // Filter: Never include Removed items
        if (state === 'Removed') return;

        resultsArray.push({
            id: itemId,
            letter: letter,
            title: title,
            url: url,
            level: level,
            state: state,
            assignedTo: assignedTo,
            type: type
        });

        // Stop traversing below Story/Bug level
        if (shouldStopTraversal(type)) return;

        if (item.relations) {
            const children = item.relations.filter(r => r.rel === "System.LinkTypes.Hierarchy-Forward");
            for (const child of children) {
                const childId = child.url.split('/').pop();
                await traverseDown(childId, visitedSet, resultsArray, level + 1);
            }
        }
    }

    async function getDirectPath(startId, statusCallback) {
        // Get path from Initiative down to startId
        const path = [];
        let currentId = startId;
        let currentItem = await fetchWorkItem(currentId);

        if (!currentItem) return null;

        // Walk up to Initiative
        const ancestors = [];
        let item = currentItem;
        let itemId = currentId;

        while (item) {
            const type = item.fields['System.WorkItemType'];
            const state = item.fields['System.State'];
            
            // Skip Removed items
            if (state !== 'Removed') {
                ancestors.unshift({
                    id: itemId,
                    letter: getTypeLetter(type),
                    title: item.fields['System.Title'],
                    url: item._links?.html?.href || '#',
                    state: state,
                    assignedTo: item.fields['System.AssignedTo']?.displayName || 'Unassigned',
                    type: type
                });
            }

            if (type === 'Initiative') break;

            const parentRel = item.relations ? item.relations.find(r => r.rel === "System.LinkTypes.Hierarchy-Reverse") : null;
            if (!parentRel) break;

            itemId = parentRel.url.split('/').pop();
            statusCallback(`â¬†ï¸ Parent: ${itemId}...`);
            item = await fetchWorkItem(itemId);
        }

        return ancestors;
    }

    async function getHierarchyData(startId, statusCallback, mode = 'direct') {
        statusCallback(`ðŸš€ Scanning ${startId}...`);

        if (mode === 'full') {
            // Full tree: climb to Initiative, then traverse all children
            const rootId = await getRootId(startId, statusCallback);
            if (!rootId) {
                statusCallback("âŒ No Root.");
                return null;
            }
            statusCallback(`ðŸŒ³ Root ${rootId}. Scanning children...`);
            const results = [];
            const visited = new Set();
            await traverseDown(rootId, visited, results);
            return results;
        } else {
            // Direct mode: show path to Initiative + all children from startId
            const directPath = await getDirectPath(startId, statusCallback);
            if (!directPath || directPath.length === 0) {
                statusCallback("âŒ No path found.");
                return null;
            }

            // Find the starting item in the path
            const startIndex = directPath.findIndex(item => item.id === startId);
            if (startIndex === -1) {
                statusCallback("âŒ Start item not found in path.");
                return null;
            }

            // Add level to path items
            directPath.forEach((item, idx) => {
                item.level = idx;
            });

            // Now traverse down from startId
            statusCallback(`â¬‡ï¸ Traversing children of ${startId}...`);
            const visited = new Set(directPath.map(item => item.id));
            const childResults = [];
            
            const startItem = await fetchWorkItem(startId);
            if (startItem && startItem.relations) {
                const children = startItem.relations.filter(r => r.rel === "System.LinkTypes.Hierarchy-Forward");
                for (const child of children) {
                    const childId = child.url.split('/').pop();
                    await traverseDown(childId, visited, childResults, startIndex + 1);
                }
            }

            return [...directPath, ...childResults];
        }
    }

    async function getRootId(startId, statusCallback) {
        let currentId = startId;
        let currentItem = await fetchWorkItem(currentId);

        if (!currentItem) return null;

        if (currentItem.fields['System.WorkItemType'] === 'Initiative') {
            statusCallback("ðŸ Started on Initiative.");
            return currentId;
        }

        let parentRel = currentItem.relations ? currentItem.relations.find(r => r.rel === "System.LinkTypes.Hierarchy-Reverse") : null;

        while (parentRel) {
            const parentId = parentRel.url.split('/').pop();
            statusCallback(`â¬†ï¸ Parent: ${parentId}...`);

            const parentItem = await fetchWorkItem(parentId);
            if (!parentItem) break;

            currentId = parentId;
            currentItem = parentItem;

            if (currentItem.fields['System.WorkItemType'] === 'Initiative') {
                statusCallback(`ðŸ”ï¸ Reached Initiative (${currentId}).`);
                break;
            }

            parentRel = currentItem.relations ? currentItem.relations.find(r => r.rel === "System.LinkTypes.Hierarchy-Reverse") : null;
        }

        return currentId;
    }

    async function getSingleItemData(id, statusCallback) {
        statusCallback(`ðŸ” Fetching ${id}...`);
        const item = await fetchWorkItem(id);
        if (!item) {
            statusCallback("âŒ Not found");
            return null;
        }
        return {
            id: id,
            letter: getTypeLetter(item.fields['System.WorkItemType']),
            title: item.fields['System.Title'],
            url: item._links?.html?.href || '#',
            state: item.fields['System.State'],
            assignedTo: item.fields['System.AssignedTo']?.displayName || 'Unassigned',
            type: item.fields['System.WorkItemType'],
            level: 0
        };
    }

    // --- Formatters & Output ---

    const Formatters = {
        text: (row, detailLevel) => {
            const indent = '  '.repeat(row.level);
            const baseText = `[${row.letter}${row.id}] ${row.title}`;
            
            if (detailLevel === 'status') {
                return `${indent}[Status: ${row.state}] ${baseText}`;
            } else if (detailLevel === 'status-assigned') {
                return `${indent}[Status: ${row.state} | Assigned: ${row.assignedTo}] ${baseText}`;
            }
            return `${indent}${baseText}`;
        },
        markdown: (row, detailLevel) => {
            const indent = '  '.repeat(row.level);
            const baseText = `[[${row.letter}${row.id}]](${row.url}) ${row.title}`;
            
            if (detailLevel === 'status') {
                return `${indent}[Status: ${row.state}] ${baseText}`;
            } else if (detailLevel === 'status-assigned') {
                return `${indent}[Status: ${row.state} | Assigned: ${row.assignedTo}] ${baseText}`;
            }
            return `${indent}${baseText}`;
        },
        html: (row, detailLevel) => {
            const indent = '&nbsp;'.repeat(row.level * 4);
            const baseText = `<a href="${row.url}">[${row.letter}${row.id}]</a> ${row.title}`;
            
            if (detailLevel === 'status') {
                return `${indent}[Status: ${row.state}] ${baseText}`;
            } else if (detailLevel === 'status-assigned') {
                return `${indent}[Status: ${row.state} | Assigned: ${row.assignedTo}] ${baseText}`;
            }
            return `${indent}${baseText}`;
        }
    };

    async function processAction(btnElement, mode, format) {
        const toolbar = btnElement.closest('.ado-ctx-toolbar');
        const idInput = toolbar.querySelector('.ado-ctx-id-input');
        const statusSpan = toolbar.querySelector('.ado-ctx-status');
        const scopeSelect = toolbar.querySelector('.ado-ctx-scope-select');
        const treeMode = toolbar.querySelector('.ado-ctx-tree-mode');
        const detailLevel = toolbar.querySelector('.ado-ctx-detail-level');

        const id = idInput.value.trim();
        const scope = scopeSelect.value;
        const treeModeValue = treeMode.value;
        const detailLevelValue = detailLevel.value;

        const updateStatus = (msg) => { statusSpan.innerText = msg; };

        if (!id) {
            alert("No ID found.");
            return;
        }

        if (scope === 'tree') {
            const data = await getHierarchyData(id, updateStatus, treeModeValue);
            if (!data) return;
            const lines = data.map(row => Formatters[format](row, detailLevelValue));
            handleOutput(lines, mode, format, `Tree (${data.length})`, updateStatus);
        }
        else {
            const itemData = await getSingleItemData(id, updateStatus);
            if (!itemData) return;
            const line = Formatters[format](itemData, detailLevelValue);
            handleOutput([line], mode, format, `Item ${id}`, updateStatus);
        }
    }

    function handleOutput(linesArray, mode, format, label, statusCallback) {
        const content = linesArray.join(format === 'html' ? '<br>' : '\n');

        if (mode === 'console') {
            console.log(`%c ðŸ“‹ ${label} [${format.toUpperCase()}]:`, 'font-weight: bold; font-size: 14px; color: #00d4ff;');
            if (format === 'html' || format === 'markdown') console.log(content);
            else linesArray.forEach(l => console.log(l));
            statusCallback(`âœ… Logged ${label}`);
        }
        else if (mode === 'clipboard') {
            if (format === 'html') GM_setClipboard(content, 'text/html');
            else GM_setClipboard(content, 'text');
            statusCallback(`âœ… Copied ${label}`);
        }
    }

    // --- DOM Injection & Scraper ---

    function injectToolbar(containerElement) {
        if (containerElement.querySelector('.ado-ctx-toolbar')) return;

        const div = document.createElement('div');
        div.className = 'ado-ctx-toolbar';

        Object.assign(div.style, {
            position: 'sticky',
            top: '0',
            width: '100%',
            minHeight: '60px',
            backgroundColor: '#252526',
            color: '#cccccc',
            display: 'flex',
            flexWrap: 'wrap',
            alignItems: 'center',
            padding: '8px 10px',
            zIndex: '999',
            fontFamily: 'Segoe UI, sans-serif',
            fontSize: '12px',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
            borderBottom: '1px solid #3e3e42',
            marginBottom: '10px'
        });

        const makeBtn = (text, title, color, actionId) => {
            return `<button class="ado-btn" data-action="${actionId}" title="${title}"
                    style="background:${color}; border:1px solid transparent; color:white; margin-left:4px; padding:2px 6px; cursor:pointer; border-radius:2px;">
                    ${text}</button>`;
        };

        const clipColor = '#0078d4';
        const conColor = '#444444';

        div.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 4px; width: 100%;">
                <span style="font-weight:bold; color: #00d4ff; margin-right:10px;">ADO</span>

                <input type="text" class="ado-ctx-id-input" readonly placeholder="..."
                       style="width: 60px; background:#333; color:#88ff88; border:1px solid #555; text-align:center; padding:2px; font-weight:bold;">

                <select class="ado-ctx-scope-select" style="background:#333; color:white; border:1px solid #555; padding:2px; border-radius:2px; margin-left:5px;">
                    <option value="single">Item</option>
                    <option value="tree">Tree</option>
                </select>

                <select class="ado-ctx-tree-mode" style="background:#333; color:white; border:1px solid #555; padding:2px; border-radius:2px; margin-left:5px;">
                    <option value="direct">Direct</option>
                    <option value="full">Full</option>
                </select>

                <select class="ado-ctx-detail-level" style="background:#333; color:white; border:1px solid #555; padding:2px; border-radius:2px; margin-left:5px;">
                    <option value="default">Default</option>
                    <option value="status">+ Status</option>
                    <option value="status-assigned">+ Status & Assigned</option>
                </select>
            </div>

            <div style="display: flex; align-items: center; width: 100%;">
                <span style="color:#aaa; margin-right:2px;">Clip:</span>
                ${makeBtn('Txt', 'Copy Text', clipColor, 'clip-text')}
                ${makeBtn('MD', 'Copy MD', clipColor, 'clip-markdown')}
                ${makeBtn('HTML', 'Copy HTML', clipColor, 'clip-html')}

                <div style="width: 1px; height: 20px; background: #555; margin: 0 5px;"></div>

                <span style="color:#aaa; margin-right:2px;">Log:</span>
                ${makeBtn('Txt', 'Log Text', conColor, 'con-text')}
                ${makeBtn('MD', 'Log MD', conColor, 'con-markdown')}
                ${makeBtn('HTML', 'Log HTML', conColor, 'con-html')}

                <div style="flex-grow: 1; text-align: right; margin-left: 10px;">
                    <span class="ado-ctx-status" style="color: #888; font-style: italic; white-space:nowrap;">...</span>
                </div>
            </div>
        `;

        containerElement.prepend(div);

        const actions = {
            'clip-text': (btn) => processAction(btn, 'clipboard', 'text'),
            'clip-markdown': (btn) => processAction(btn, 'clipboard', 'markdown'),
            'clip-html': (btn) => processAction(btn, 'clipboard', 'html'),
            'con-text': (btn) => processAction(btn, 'console', 'text'),
            'con-markdown': (btn) => processAction(btn, 'console', 'markdown'),
            'con-html': (btn) => processAction(btn, 'console', 'html'),
        };

        div.querySelectorAll('.ado-btn').forEach(btn => {
            btn.onclick = function() {
                const actionKey = this.getAttribute('data-action');
                if (actions[actionKey]) actions[actionKey](this);
            };
        });
    }

    // --- Observer Logic ---

    function extractIdFromContainer(container) {
        const link = container.querySelector(LINK_SELECTOR);
        if (link && link.href) {
            const match = link.href.match(/\/edit\/(\d+)/);
            if (match && match[1]) return match[1];
        }
        return null;
    }

    function scanAndInject() {
        const containers = document.querySelectorAll(CONTAINER_SELECTOR);

        containers.forEach(container => {
            injectToolbar(container);

            const id = extractIdFromContainer(container);
            const toolbar = container.querySelector('.ado-ctx-toolbar');
            if (toolbar && id) {
                const input = toolbar.querySelector('.ado-ctx-id-input');
                const status = toolbar.querySelector('.ado-ctx-status');

                if (input.value !== id) {
                    input.value = id;
                    status.innerText = "Ready";
                }
            }
        });
    }

    // --- Start ---
    const observer = new MutationObserver(scanAndInject);
    observer.observe(document.body, { childList: true, subtree: true });

    setTimeout(scanAndInject, 1500);

    console.log("ADO Contextual Printer v2.0 loaded (Enhanced).");

})();
